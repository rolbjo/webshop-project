import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-OL3AADLO.js";

// node_modules/fastest-levenshtein/esm/mod.js
var mod_exports = {};
__export(mod_exports, {
  closest: () => closest,
  distance: () => distance
});
var peq, myers_32, myers_x, distance, closest;
var init_mod = __esm({
  "node_modules/fastest-levenshtein/esm/mod.js"() {
    peq = new Uint32Array(65536);
    myers_32 = (a, b) => {
      const n = a.length;
      const m = b.length;
      const lst = 1 << n - 1;
      let pv = -1;
      let mv = 0;
      let sc = n;
      let i = n;
      while (i--) {
        peq[a.charCodeAt(i)] |= 1 << i;
      }
      for (i = 0; i < m; i++) {
        let eq = peq[b.charCodeAt(i)];
        const xv = eq | mv;
        eq |= (eq & pv) + pv ^ pv;
        mv |= ~(eq | pv);
        pv &= eq;
        if (mv & lst) {
          sc++;
        }
        if (pv & lst) {
          sc--;
        }
        mv = mv << 1 | 1;
        pv = pv << 1 | ~(xv | mv);
        mv &= xv;
      }
      i = n;
      while (i--) {
        peq[a.charCodeAt(i)] = 0;
      }
      return sc;
    };
    myers_x = (b, a) => {
      const n = a.length;
      const m = b.length;
      const mhc = [];
      const phc = [];
      const hsize = Math.ceil(n / 32);
      const vsize = Math.ceil(m / 32);
      for (let i = 0; i < hsize; i++) {
        phc[i] = -1;
        mhc[i] = 0;
      }
      let j = 0;
      for (; j < vsize - 1; j++) {
        let mv2 = 0;
        let pv2 = -1;
        const start2 = j * 32;
        const vlen2 = Math.min(32, m) + start2;
        for (let k = start2; k < vlen2; k++) {
          peq[b.charCodeAt(k)] |= 1 << k;
        }
        for (let i = 0; i < n; i++) {
          const eq = peq[a.charCodeAt(i)];
          const pb = phc[i / 32 | 0] >>> i & 1;
          const mb = mhc[i / 32 | 0] >>> i & 1;
          const xv = eq | mv2;
          const xh = ((eq | mb) & pv2) + pv2 ^ pv2 | eq | mb;
          let ph = mv2 | ~(xh | pv2);
          let mh = pv2 & xh;
          if (ph >>> 31 ^ pb) {
            phc[i / 32 | 0] ^= 1 << i;
          }
          if (mh >>> 31 ^ mb) {
            mhc[i / 32 | 0] ^= 1 << i;
          }
          ph = ph << 1 | pb;
          mh = mh << 1 | mb;
          pv2 = mh | ~(xv | ph);
          mv2 = ph & xv;
        }
        for (let k = start2; k < vlen2; k++) {
          peq[b.charCodeAt(k)] = 0;
        }
      }
      let mv = 0;
      let pv = -1;
      const start = j * 32;
      const vlen = Math.min(32, m - start) + start;
      for (let k = start; k < vlen; k++) {
        peq[b.charCodeAt(k)] |= 1 << k;
      }
      let score = m;
      for (let i = 0; i < n; i++) {
        const eq = peq[a.charCodeAt(i)];
        const pb = phc[i / 32 | 0] >>> i & 1;
        const mb = mhc[i / 32 | 0] >>> i & 1;
        const xv = eq | mv;
        const xh = ((eq | mb) & pv) + pv ^ pv | eq | mb;
        let ph = mv | ~(xh | pv);
        let mh = pv & xh;
        score += ph >>> m - 1 & 1;
        score -= mh >>> m - 1 & 1;
        if (ph >>> 31 ^ pb) {
          phc[i / 32 | 0] ^= 1 << i;
        }
        if (mh >>> 31 ^ mb) {
          mhc[i / 32 | 0] ^= 1 << i;
        }
        ph = ph << 1 | pb;
        mh = mh << 1 | mb;
        pv = mh | ~(xv | ph);
        mv = ph & xv;
      }
      for (let k = start; k < vlen; k++) {
        peq[b.charCodeAt(k)] = 0;
      }
      return score;
    };
    distance = (a, b) => {
      if (a.length < b.length) {
        const tmp = b;
        b = a;
        a = tmp;
      }
      if (b.length === 0) {
        return a.length;
      }
      if (a.length <= 32) {
        return myers_32(a, b);
      }
      return myers_x(a, b);
    };
    closest = (str, arr) => {
      let min_distance = Infinity;
      let min_index = 0;
      for (let i = 0; i < arr.length; i++) {
        const dist = distance(str, arr[i]);
        if (dist < min_distance) {
          min_distance = dist;
          min_index = i;
        }
      }
      return arr[min_index];
    };
  }
});

// node_modules/fast-levenshtein/levenshtein.js
var require_levenshtein = __commonJS({
  "node_modules/fast-levenshtein/levenshtein.js"(exports, module) {
    (function() {
      "use strict";
      var collator;
      try {
        collator = typeof Intl !== "undefined" && typeof Intl.Collator !== "undefined" ? Intl.Collator("generic", { sensitivity: "base" }) : null;
      } catch (err) {
        console.log("Collator could not be initialized and wouldn't be used");
      }
      var levenshtein = (init_mod(), __toCommonJS(mod_exports));
      var prevRow = [], str2Char = [];
      var Levenshtein = {
        /**
         * Calculate levenshtein distance of the two strings.
         *
         * @param str1 String the first string.
         * @param str2 String the second string.
         * @param [options] Additional options.
         * @param [options.useCollator] Use `Intl.Collator` for locale-sensitive string comparison.
         * @return Integer the levenshtein distance (0 and above).
         */
        get: function(str1, str2, options) {
          var useCollator = options && collator && options.useCollator;
          if (useCollator) {
            var str1Len = str1.length, str2Len = str2.length;
            if (str1Len === 0)
              return str2Len;
            if (str2Len === 0)
              return str1Len;
            var curCol, nextCol, i, j, tmp;
            for (i = 0; i < str2Len; ++i) {
              prevRow[i] = i;
              str2Char[i] = str2.charCodeAt(i);
            }
            prevRow[str2Len] = str2Len;
            var strCmp;
            for (i = 0; i < str1Len; ++i) {
              nextCol = i + 1;
              for (j = 0; j < str2Len; ++j) {
                curCol = nextCol;
                strCmp = 0 === collator.compare(str1.charAt(i), String.fromCharCode(str2Char[j]));
                nextCol = prevRow[j] + (strCmp ? 0 : 1);
                tmp = curCol + 1;
                if (nextCol > tmp) {
                  nextCol = tmp;
                }
                tmp = prevRow[j + 1] + 1;
                if (nextCol > tmp) {
                  nextCol = tmp;
                }
                prevRow[j] = curCol;
              }
              prevRow[j] = nextCol;
            }
            return nextCol;
          }
          return levenshtein.distance(str1, str2);
        }
      };
      if (typeof define !== "undefined" && define !== null && define.amd) {
        define(function() {
          return Levenshtein;
        });
      } else if (typeof module !== "undefined" && module !== null && typeof exports !== "undefined" && module.exports === exports) {
        module.exports = Levenshtein;
      } else if (typeof self !== "undefined" && typeof self.postMessage === "function" && typeof self.importScripts === "function") {
        self.Levenshtein = Levenshtein;
      } else if (typeof window !== "undefined" && window !== null) {
        window.Levenshtein = Levenshtein;
      }
    })();
  }
});
export default require_levenshtein();
//# sourceMappingURL=fast-levenshtein.js.map
